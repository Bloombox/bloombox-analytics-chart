
<!--
`<bloombox-analytics-chart>` provides chart UI that visualizes
data from Bloombox analytics streams.

@group Bloombox Elements
@element bloombox-analytics-chart
@demo demo/index.html
@homepage bloombox.github.io
-->

<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<link rel="import" href="../paper-progress/paper-progress.html">

<link rel="import" href="../bloombox-styles/bloombox-styles.html">

<link rel="import" href="./behaviors/bloombox-pie-chart-behavior.html">
<link rel="import" href="./behaviors/bloombox-line-chart-behavior.html">
<link rel="import" href="./behaviors/bloombox-time-format-behavior.html">

<script type="text/javascript" src="../keen-js/dist/keen-query.min.js"></script>


<dom-module id="bloombox-analytics-chart">
  <template strip-whitespace>
    <style is="custom-style" include="bloombox-styles">
      :host {
        display: flex;
        justify-content: center;
      }

      :host main {
        width: var(--bloombox-chart-width, 100%);
        min-height: var(--bloombox-chart-min-height, 200px);
        display: flex;
        justify-content: center;
        align-items: center;
        border: var(--bloombox-chart-border, 1px solid #dedede);
        border-radius: var(--bloombox-chart-border-radius, 3px);
      }

      :host main.sparkline {
        border: none;
        max-width: 200px;
        max-height: 75px;
        min-height: 75px;
      }

      paper-progress.chart-loading {
        --paper-progress-indeterminate-cycle-duration: 5s;
      }

      div.chart-container {
        display: flex;
        position: relative;
        flex-direction: column;
        justify-content: center;
        min-height: var(--bloombox-chart-min-height, 200px);
      }

      :host main.sparkline div.chart-container {
        min-height: 0 !important;
        height: 75px;
      }

      div.chart-container,
      svg {
        width: 100%;
        height: 100%;
      }

      div.chart-heading-container {
        position: absolute;
        top: 0;
        left: 0;
        padding-left: 5px;
        max-height: 20px;
      }

      span.chart-heading {
        text-transform: uppercase;
        font-size: 8pt;
        user-select: none;
        cursor: default;
      }
    </style>

    <main class$="[[chartType]]">
      <div class="loading-overlay" hidden$="[[!_loading]]">
        <paper-progress indeterminate class="chart-loading"></paper-progress>
      </div><!-- end div.loading-overlay -->
      <div class="chart-container" hidden$="[[_loading]]">
        <div class="chart-heading-container">
          <span class="chart-heading">[[heading]]</span>
        </div><!-- end div.chart-heading-container -->
        <svg id="chartContent" class="chart-content"></svg><!-- end svg.chart-content -->
      </div><!-- end div.chart-container -->
    </main>
  </template>

  <script>
    var BloomboxAnalyticsChart = Polymer.BloomboxAnalyticsChart = Polymer({
      is: "bloombox-analytics-chart",

      listeners: {
        "iron-resize": "_onResize"
      },

      observers: [
        "_queryShouldChange(_booted, _client, environment, partner, location, collection, readKey, analysisType, dataType, groupBy, timeframe, timeframeMode, timezone, interval, filters)",
        "_queryDidChange(_client, _query)",
        "_scheduleRender(_booted, _data, _dimensions)"
      ],

      behaviors: [
        Polymer.IronResizableBehavior,
        Polymer.BloomboxPieChartBehavior,
        Polymer.BloomboxLineChartBehavior,
        Polymer.BloomboxTimeFormatBehavior
      ],

      properties: {
        /**
         * Whether or not this chart has "booted up" yet, in
         * terms of receiving and executing an initial query.
         */
        _booted: {
          type: Boolean,
          notify: true,
          readOnly: true
        },

        /**
         * Holds calculated width/height dimensions for the
         * local widget.
         */
        _dimensions: {
          type: Object,
          notify: true,
          readOnly: true
        },

        /**
         * Flag indicating that a render job is already
         * scheduled for the local chart.
         */
        _renderScheduled: {
          type: Boolean,
          notify: true,
          readOnly: true,
          value: false
        },

        /**
         * Whether or not this chart should currently be
         * showing as loading/busy.
         */
        _loading: {
          type: Boolean,
          notify: true,
          readOnly: true,
          value: true
        },

        /**
         * Whether or not this chart has completed a full
         * render yes.
         */
        _rendered: {
          type: Boolean,
          notify: true,
          readOnly: true,
          value: false
        },

        /**
         * Underlying `KeenClient` object that manages
         * interaction with the Keen API.
         */
        _client: {
          type: Object,
          notify: false,
          computed: "_buildKeenClient(projectId, environment, partner, readKey)"
        },

        /**
         * Underlying query object that will supply this chart.
         */
        _query: {
          type: Object,
          notify: false,
          readOnly: true,
          reflectToAttribute: false
        },

        /**
         * Underlying chart data, in raw form.
         */
        _data: {
          type: Object,
          notify: false,
          readOnly: true,
          reflectToAttribute: false
        },

        /**
         * Underlying D3 chart object.
         */
        _chart: {
          type: Object,
          notify: false,
          readOnly: true,
          reflectToAttribute: false
        },

        /**
         * Sensible name for this chart, to be displayed above
         * the chart to explain it to the user.
         */
        heading: {
          type: String,
          notify: true
        },

        /**
         * Target Keen project to fetch data from.
         */
        projectId: {
          type: String,
          notify: false,
          reflectToAttribute: false
        },

        /**
         * Data environment that we are operating under. Defaults
         * to the `sandbox`.
         */
        environment: {
          type: String,
          notify: false,
          value: "sandbox",
          reflectToAttribute: true
        },

        /**
         * Partner account ID that we are visualizing data for.
         */
        partner: {
          type: String,
          notify: false,
          reflectToAttribute: true
        },

        /**
         * Partner location ID that we are visualizing data for, if
         * filters so restrict the current user-desired query.
         */
        location: {
          type: String,
          notify: false,
          value: null,
          reflectToAttribute: true
        },

        /**
         * Keen collection that we should be visualizing data from.
         */
        collection: {
          type: String,
          notify: false,
          computed: "_computeEventCollection(dataType)",
          reflectToAttribute: true
        },

        /**
         * Read-scoped API key to use for interactions with the Keen
         * Event Analysis API.
         */
        readKey: {
          type: String,
          notify: false,
          reflectToAttribute: true
        },

        /**
         * Type of chart to use/display via this widget. Valid options
         * include:
         * - `bar`: For a bar chart, usually x-indexed by value
         * - `line`: For a line chart, usually x-indexed by time
         * - `multiline`: Like above but a multi-category line chart
         * - `sparkline`: One lone line with no axes at all
         * - `column`: For a column chart, usually x-indexed by time
         * - `pie`: For a percentage/zero-sum-style chart
         * - `calendar`: GitHub contribution-calendar-style viz
         */
        chartType: {
          type: String,
          notify: false,
          value: "column",
          reflectToAttribute: true
        },

        /**
         * Type of analysis to perform when querying for data. Defaults
         * to a simple global non-unique count of collection events.
         * Valid options are provided by KeenJS:
         * - `count`: Count items without unique-ifying
         * - `count_unique`: Count unique items by property
         * - `sum`: Add together many values inside events
         * - `minimum`: Find the minimum value out of many inside events
         * - `maximum`: Find the maximum value out of many inside events
         * - `average`: Average a number across many event values
         * - `percentile`: Calculate an N-percentile across many events
         * - `median`: Calculate a median across many events
         */
        analysisType: {
          type: String,
          notify: false,
          value: "count",
          reflectToAttribute: true
        },

        /**
         * Kind of event data to display in this chart. Valid options
         * include:
         * - `sections`: Data about section usage inside the app.
         * - `products`: Data about actual products inside the app.
         * - `locations`: Data about individual partner locations.
         */
        dataType: {
          type: String,
          notify: false,
          value: "sections",
          reflectToAttribute: true
        },

        /**
         * Property to group events by, producing a value according to
         * `analysisType` after combining like events that have a
         * matching value for the property named by `groupBy`.
         */
        groupBy: {
          type: String,
          notify: false,
          value: null,
          reflectToAttribute: true
        },

        /**
         * Specifies the named timeframe for which the user would like
         * to view analytics data. These are predefined time windows,
         * except in the case of `custom` mode. Valid options include:
         * - `1_hour`: last 60 minutes
         * - `6_hours`: last 6 hours
         * - `12_hours`: last 12 hours
         * - `1_day`: last 24 hours
         * - `3_days`: last 72 hours
         * - `1_week`: last week
         * - `1_month`: last month
         * - `1_year`: last year
         */
        timeframe: {
          type: String,
          notify: false,
          value: "1_day",
          reflectToAttribute: true
        },

        /**
         * Specifies the timeframe mode, either `this` or `previous`.
         * See Keen JS documentation for more info.
         */
        timeframeMode: {
          type: String,
          notify: false,
          value: "this",
          reflectToAttribute: true
        },

        /**
         * Timezone offset to apply before visualizing/interpolating
         * the resulting event dataset.
         */
        timezone: {
          type: Object,
          notify: false,
          value: -28800  /* defaults to Pacific Time */
        },

        /**
         * Time interval to map data over. These values are predefined
         * and provided by Keen JS. Some examples:
         *
         * ### Predefined Intervals
         * - `minutely`
         * - `hourly`
         * - `daily`
         * - `weekly`
         * - `monthly`
         * - `yearly`
         *
         * ### Custom Intervals
         * - `every_30_minutes`
         * - `every_8_hours`
         * - `every_3_days`
         * - `every_2_weeks`
         * - `every_6_months`
         * - `every_3_years`
         */
        interval: {
          type: String,
          notify: false,
          value: null
        },

        /**
         * Specifies an optional set of filters to enforce during
         * query execution. Items matching this subquery will be
         * rejected for inclusion in the resulting set of data.
         */
        filters: {
          type: Array,
          notify: false,
          reflectToAttribute: true,
          value: function() {
            return [];
          }
        }
      },

      /**
       * Build a JS `KeenClient` for use with Keen's API.
       */
      _buildKeenClient: function(project, environment, partner, readKey) {
        return new Keen({
          projectId: project,
          readKey: readKey
        });
      },

      /**
       * Compute the name of the event collection that we should
       * use as our event data source.
       */
      _computeEventCollection: function(dataType) {
        var lowered = dataType.toLowerCase();
        if (lowered === "products")
          return "products";
        if (lowered === "locations")
          return "locations";
        return "screens";
      },

      /**
       * Event handler for dimension changes.
       */
      _onResize: function(event) {
        var width = this.offsetWidth,
            height = this.offsetHeight;
        this._set_dimensions({
          width: width,
          height: height
        });
      },

      /**
       * Observer that propagates configuration changes into the
       * underlying chart query.
       */
      _queryShouldChange: function(_booted, _client, environment, partner, location, collection, readKey, analysisType, dataType, groupBy, timeframe, timeframeMode, timezone, interval, filters) {
        var timeframeFormat = [timeframeMode, timeframe].join("_"),
            configPayload = {
              "event_collection": collection,
              "timeframe": timeframeFormat
            };

        if (_booted === true) {
          if (groupBy && groupBy.length > 0)
            configPayload["group_by"] = groupBy;
          if (timezone && (typeof timezone === "number" || typeof timezone === "string"))
            configPayload["timezone"] = timezone;
          if (interval && typeof interval === "string")
            configPayload["interval"] = interval;
          if (filters && Array.isArray(filters) && filters.length > 0)
            configPayload["filters"] = filters;
          this._set_query(new Keen.Query(analysisType, configPayload));
        }
      },

      /**
       * Observer that applies a query/client pair to accomplish
       * fetching our data and rendering our chart.
       */
      _queryDidChange: function(_client, _query) {
        var that = this;
        _client.run(_query, function(err, response) {
          that._didReceiveResponse(err, response);
        });
      },

      /**
       * Handles an initial response from the Keen Analysis API,
       * once a query has been run.
       */
      _didReceiveResponse: function(error, response) {
        if (error) {
          console.error("An error occurred fetching data from the Keen Analysis API.", error);
        } else {
          this._set_data(response.result);
        }
      },

      /**
       * Schedule and debounce chart render ops, according to
       * whether the DOM and dataset are ready.
       */
      _scheduleRender: function(booted, data, dimensions) {
        var that = this;
        if (this._renderScheduled !== true) {
          if (booted === true && dimensions) {
            this._renderScheduled = true;
            this.debounce("_renderChart", function() {
              that._renderChart();
              that._renderScheduled = false;
            }, 100);
          } else {
            this.async(this._scheduleRender, 100);
          }
        }
        // there is already a render scheduled
      },

      /**
       * Re-renders the current chart.
       */
      _renderChart: function() {
        // render chart data into d3 chart
        // DT format from keen: `2016-10-18T09:00:00.000Z`
        var width = this._dimensions.width,
            height = this._dimensions.height,
            data = this._data,
            svg = d3.select(this.$.chartContent),
            parseTime = d3.timeParse("%Y-%m-%dT%H:%M:%S.%L%Z"),
            chartRenderer = this[this.chartType + "Chart"],
            formatTime;

        if (this._rendered === true)
          // clear existing chart
          svg.selectAll("*").remove();

        // cannot proceed without chart renderer
        if (!chartRenderer)
          throw "Failed to resolve chart renderer of type '" + this.chartType + "'.";

        // if we have an interval, we need a valid formatter
        if (this.interval) {
          formatTime = this.timeFormatters[this.interval];
          if (!formatTime)
            throw "Failed to resolve time formatter for interval '" + this.interval + "'.";
        }

        // prepare-phase of chart rendering
        chartRenderer.prepare(parseTime, formatTime, width, height, svg, this, data);

        this.async(function() {
          this._set_loading(false);
          this._set_rendered(true);
        }, 200);
      },

      /**
       * Force a refresh of chart data and then re-render.
       */
      refresh: function() {
        console.log("Refreshing chart data...");
        this._queryDidChange(this._client, this._query);
      },

      /**
       * Lifecycle callback, dispatched each time this element is
       * stamped into the DOM.
       */
      attached: function() {
        if (!this._booted)
          this._set_booted(true);
      }
    });
  </script>
</dom-module>
